# 类与对象初步

### 为什么 `C a = C(...)` 没有调用复制构造函数？

关于复制构造函数的调用时机，上课时提到“用一个对象去初始化同类的另一个对象时”会调用复制构造函数，但在ppt的28页里，`Test array2[3] = {Test(2, 3), Test(1, 2), 1};` 这一句实际上不会调用复制构造函数，而会调用普通的构造函数 `Test(int, int)`。这是否是一个特例？

非常好的问题。你的观察是正确的，这个例子**理论上**应当先调用一次 `Test(int, int)`，随后调用复制构造函数将这个临时值复制到 `array2`的元素中。但是编译器在这里做了优化，将第二步给去掉——即直接从两个 `int`构造 `array2[_]`。

另外，C++17 通过对“纯右值”这一术语的修正，强制性要求编译器实现这一优化。所以你此时不可能看到复制构造函数被调用。不过，如果你将标准降到 C++14，并**同时**关闭编译器优化，就可以观察到复制构造函数被调用了。[演示代码](https://godbolt.org/z/aKhf5dK5d)，尝试修改编译器参数以观察结果的不同。

### 函数析构的时候到底发生了什么？析构顺序是？

一个不够精确的结论：调用析构函数、释放所有“基本类型”的变量、按构造顺序的逆序调用所有成员类的析构函数

（对于继承类和父类相关，等学习完相关内容后再补充）

来源：https://en.cppreference.com/w/cpp/language/destructor

对于如何自己寻找此类问题的答案，见[如何找到问题的答案](/24spring/before_ask/how_to_find_answers)。
