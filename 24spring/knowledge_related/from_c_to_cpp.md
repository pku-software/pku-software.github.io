# 从 C 到 C++

### 变量定义中`*`和`&`的含义？

**Q:** `int *a1, a2;`中只有`a1`被定义为了`int*`，请问对于`int &a, b;`有没有相同的性质？对于下面的例子，用`intpoint`为何不会有类似问题？

```c++
using intpoint = int*;
intpoint p, q;
```

**A:** C++中，变量定义的语义如下：

```c++
类型 标识符1, 标识符2, ...;
```

这里的含义是，每个标识符表达的值类型都是声明的`类型`。比如下面这个例子，`a`, `*b`, `**c`的类型都是`int`，`b`就是`int`的指针，`c`就是`int`指针的指针。引用符号`&`也遵循同样的规则。

```c++
int a, *b, **c; // 一个例子
```

当使用`using intpoint = int*`时，实际上是定义了一个新的类型别名。因此，之后声明的所有变量（如`p`, `q`）都会是这个新类型（即`int*`）。

### `delete`如何使用？

**Q:** `delete`内存空间应该在变量完全使用完后进行吗？是不是被`delete`掉之后这个变量就不再存在于程序中并且不可访问了？

**A:** 可以这么理解。但是要注意的是，只有通过`new`手动申请的内存空间需要`delete`进行释放。释放内存是告知系统，对应的 内存空间不再需要了。下面的例子中，`delete a`之后，`a`指向的内存空间就不能再被使用了，但是`a`本身仍然存在，储存着之前分配的内存地址。这里一定要进行妥善处理，不能继续使用`a`指向的内存，否则将导致`use-after-free`错误。

```c++
int *a = new int;
*a = 5;
delete a;
std::cout << a << std::endl; // a仍然存在，但其指向的内存已不可用
```

### 为什么 C++ 要有引用这个概念？好像指针都能代替。

仅就《从 C 到 C++》这一课的内容来看，C++ 的引用的使用场景确实都可以用指针来代替。但是，我们之后会讲到“运算符重载”，为了实现必要的运算符重载操作，引用是不可或缺的。

### 函数返回引用是什么意思？为什么这样就能 `cin >>` 一个函数调用的结果？

一言以蔽之：函数返回引用是将**函数调用表达式**作为某个变量的别名。比如，如果函数 `f`返回 `int&`，那么 `cin >> f();` 就是输入到某个 `int` 类型变量，而 `f() = 42;` 就是对这个变量赋值。

具体是哪个变量的别名呢？也很显然，就是你在函数定义的 `return` 语句中给出的变量名。如果你在 `f` 的定义中 `return a;`，那么 `f()` 就是 `a` 的别名。这个逻辑没有那么困难，只是需要转变一下思维。

### `const T&`作为函数返回值类型时，能否用来返回局部变量？

不可以。任何情况下返回绑定到局部变量的引用，都是**悬垂引用**。

意思就是 `T&``const T&``T&&`等等类型都是引用类型，它们一旦出现在返回值类型的位置，就意味着悬垂引用的可能性。

当引用绑定到局部变量时，函数返回后这个局部变量已经消亡，从而函数调用表达式的结果是一个不存在的变量的别名，从而导致未定义行为。

或许你的编译器和运行环境比较“巧”，没有出现意外的错误；但这仍然是很危险的。

### Lambda 表达式的捕获语法 `[]` 是什么？

当 Lambda 表达式没有捕获时，它的表现和普通函数一样：只能访问函数体内的局部变量、形参，以及全局变量；不能访问其它函数的局部变量。比如，尽管某个 Lambda 表达式定义在 `main`函数体内，但它仍然不能访问 `main`当中的局部变量——因为对于 Lambda 表达式而言，`main`是一个不同的函数，不能访问别人的局部变量。

然而在使用 Lambda 时，访问其它函数的局部变量又是非常常见的需求，所以才有了“捕获列表”。所有在捕获列表中出现的名字，都会复制一份到 Lambda 表达式内部，如同 Lambda 表达式函数体本身的局部变量。如果以“引用捕获”形式写出的名字（即 `&foo` 这种），则会如同 Lambda 表达式内部声明了一个绑定到外界函数局部变量的引用（如果在调用 Lambda 表达式前，外界函数已经返回了，那么这就是悬垂引用）。

`[=]` 用于将所有的外部变量以值复制的形式捕获，`[&]` 用于将所有的外部变量以引用形式捕获。

### 如何声明持有函数指针的数组？

先给答案：`ReturnType (*arrayName[N])(ParamType);`。但是这个回答不会让我感到满意，因为它太复杂了，不符合人类的思维模式。

充分利用类型别名的定义，就可以让这种声明变得易如反掌。看下面的例子：

```cpp
using FuncType = int(int, int); // FuncType 是一个函数类型，接受两个 int 返回 int
FuncType* array[10]; // array 是 10 个元素的数组，元素类型是指向 FuncType 的指针
```

看上去就舒服很多了。这也解答了一些同学对 `using` 别名声明有什么用的疑问。
