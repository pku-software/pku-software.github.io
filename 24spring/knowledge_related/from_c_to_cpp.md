# 从 C 到 C++

### 变量定义中`*`和`&`的含义？

**Q:** `int *a1, a2;`中只有`a1`被定义为了`int*`，请问对于`int &a, b;`有没有相同的性质？对于下面的例子，用`intpoint`为何不会有类似问题？

```c++
using intpoint = int*;
intpoint p, q;
```

**A:** 第一个问题的回答是：**是**，C++ 的引用声明符具有和 C 的指针声明符类似的语法。即 `int &a{b}, c{d};` 中，`c` 不是 `d` 的引用，而是从 `d` 初始化的 `int` 类型变量。
   
> 在 C 中，指针声明符、数组声明符、函数声明符等语法规则是参照解地址表达式、下标表达式和函数调用表达式的“形式”而设计的，比如 `int *p, **q` 隐含 `*p` 表达式和 `**q` 表达式都将具有 `int` 类型。但是这种设计偏好非常古怪，我们不建议如此使用。在 C++ 中，我们强烈建议每条声明只引入一个标识符，如 `int* p;` 或 `int& r = a;`，并将指针声明符、引用声明符靠左对齐以体现 `p` 或 `r` 的类型。
> 
>> P.S. 不存在“引用的引用”类型，`int &r{...}, &&r2{...};` 中的 `&&` 是另一个语法“右值引用”。

对于第二个问题，`using intpoint = int*;` 所表达的含义是将 `intpoint` 作为 `int*` 类型的别名。**这并非文本替换的过程**。除了你说的 `intpoint p, q;` 将 `p` 和 `q` 都声明为 `intpoint` 类型，以下的例子也可供研究：

```cpp
using intpoint = int*;
const intpoint ptr{}; // ptr 是 int* const 类型，为什么？

using constInt = const int;
constInt* ptr2{};       // 它的类型又是什么？
const constInt* ptr3{}; // 这个呢？
```

### `delete` 如何使用？

**Q:** `delete` 内存空间应该在变量完全使用完后进行吗？是不是被 `delete` 掉之后这个变量就不再存在于程序中并且不可访问了？

**A:** 可以这么理解。但是要注意的是，只有通过 `new` 手动申请的内存空间需要 `delete` 进行释放。释放内存是告知系统，对应的 内存空间不再需要了。下面的例子中，`delete a` 之后，`a` 指向的内存空间就不能再被使用了，但是 `a` 本身仍然存在，储存着之前分配的内存地址。这里一定要进行妥善处理，不能继续使用 `a` 指向的内存，否则将导致 "use-after-free" 错误。

```c++
int *a = new int;
*a = 5;
delete a;
std::cout << a << std::endl; // a仍然存在，但其指向的内存已不可用
// std::cout << *a << std::endl; // 错误行为（未定义行为）
```

### 为什么 C++ 要有引用这个概念？好像指针都能代替。

仅就《从 C 到 C++》这一课的内容来看，C++ 的引用的使用场景确实都可以用指针来代替。但是，我们之后会讲到“运算符重载”，为了实现必要的运算符重载操作，引用是不可或缺的。

### 函数返回引用是什么意思？为什么这样就能 `cin >>` 一个函数调用的结果？

一言以蔽之：函数返回引用是将**函数调用表达式**作为某个变量的别名。比如，如果函数 `f`返回 `int&`，那么 `cin >> f();` 就是输入到某个 `int` 类型变量，而 `f() = 42;` 就是对这个变量赋值。

具体是哪个变量的别名呢？也很显然，就是你在函数定义的 `return` 语句中给出的变量名。如果你在 `f` 的定义中 `return a;`，那么 `f()` 就是 `a` 的别名。这个逻辑没有那么困难，只是需要转变一下思维。

### `const T&` 作为函数返回值类型时，能否用来返回局部变量？

不可以。任何情况下返回绑定到局部变量的引用，都是**悬垂引用**。

意思就是 `T&`、`const T&`、`T&&` 等等类型都是引用类型，它们一旦出现在返回值类型的位置，就意味着悬垂引用的可能性。

当引用绑定到局部变量时，函数返回后这个局部变量已经消亡，从而函数调用表达式的结果是一个不存在的变量的别名，从而导致未定义行为。

或许你的编译器和运行环境比较“巧”，没有出现意外的错误；但这仍然是很危险的。

### Lambda 表达式的捕获语法 `[]` 是什么？

当 Lambda 表达式没有捕获时，它的表现和普通函数一样：只能访问函数体内的局部变量、形参，以及全局变量；不能访问其它函数的局部变量。比如，尽管某个 Lambda 表达式定义在 `main` 函数体内，但它仍然不能访问 `main` 当中的局部变量——因为对于 Lambda 表达式而言，`main` 是一个不同的函数，不能访问别人的局部变量。

然而在使用 Lambda 时，访问其它函数的局部变量又是非常常见的需求，所以才有了“捕获列表”。所有在捕获列表中出现的名字，都会复制一份到 Lambda 表达式内部，如同 Lambda 表达式函数体本身的局部变量。如果以“引用捕获”形式写出的名字（即 `&foo` 这种），则会如同 Lambda 表达式内部声明了一个绑定到外界函数局部变量的引用（如果在调用 Lambda 表达式前，外界函数已经返回了，那么这就是悬垂引用）。

`[=]` 用于将所有的外部变量以值复制的形式捕获，`[&]` 用于将所有的外部变量以引用形式捕获。

### 如何声明持有函数指针的数组？

先给答案：`ReturnType (*arrayName[N])(ParamType);`。但是这个回答不太令人满意，因为它太复杂了，不符合人类的思维模式。

充分利用类型别名的定义，就可以让这种声明变得易如反掌。看下面的例子：

```cpp
using FuncType = int(int, int); // FuncType 是一个函数类型，接受两个 int 返回 int
FuncType* array[10]; // array 是 10 个元素的数组，元素类型是指向 FuncType 的指针
```

看上去就舒服很多了。这也解答了一些同学对 `using` 别名声明有什么用的疑问。
