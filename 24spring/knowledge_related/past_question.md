
### 为什么 C++ 要有引用这个概念？好像指针都能代替。

仅就《从 C 到 C++》这一课的内容来看，C++ 的引用的使用场景确实都可以用指针来代替。但是，我们之后会讲到“运算符重载”，为了实现必要的运算符重载操作，引用是不可或缺的。

### 函数返回引用是什么意思？为什么这样就能 `cin >>` 一个函数调用的结果？

一言以蔽之：函数返回引用是将**函数调用表达式**作为某个变量的别名。比如，如果函数 `f`返回 `int&`，那么 `cin >> f();` 就是输入到某个 `int` 类型变量，而 `f() = 42;` 就是对这个变量赋值。

具体是哪个变量的别名呢？也很显然，就是你在函数定义的 `return` 语句中给出的变量名。如果你在 `f` 的定义中 `return a;`，那么 `f()` 就是 `a` 的别名。这个逻辑没有那么困难，只是需要转变一下思维。

### `const T&` 作为函数返回值类型时，能否用来返回局部变量？

不可以。任何情况下返回绑定到局部变量的引用，都是**悬垂引用**。

意思就是 `T&`、`const T&`、`T&&` 等等类型都是引用类型，它们一旦出现在返回值类型的位置，就意味着悬垂引用的可能性。

当引用绑定到局部变量时，函数返回后这个局部变量已经消亡，从而函数调用表达式的结果是一个不存在的变量的别名，从而导致未定义行为。

或许你的编译器和运行环境比较“巧”，没有出现意外的错误；但这仍然是很危险的。

### Lambda 表达式的捕获语法 `[]` 是什么？

当 Lambda 表达式没有捕获时，它的表现和普通函数一样：只能访问函数体内的局部变量、形参，以及全局变量；不能访问其它函数的局部变量。比如，尽管某个 Lambda 表达式定义在 `main` 函数体内，但它仍然不能访问 `main` 当中的局部变量——因为对于 Lambda 表达式而言，`main` 是一个不同的函数，不能访问别人的局部变量。

然而在使用 Lambda 时，访问其它函数的局部变量又是非常常见的需求，所以才有了“捕获列表”。所有在捕获列表中出现的名字，都会复制一份到 Lambda 表达式内部，如同 Lambda 表达式函数体本身的局部变量。如果以“引用捕获”形式写出的名字（即 `&foo` 这种），则会如同 Lambda 表达式内部声明了一个绑定到外界函数局部变量的引用（如果在调用 Lambda 表达式前，外界函数已经返回了，那么这就是悬垂引用）。

`[=]` 用于将所有的外部变量以值复制的形式捕获，`[&]` 用于将所有的外部变量以引用形式捕获。
