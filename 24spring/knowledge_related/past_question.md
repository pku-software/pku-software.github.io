
### 为什么 C++ 要有引用这个概念？好像指针都能代替。

仅就《从 C 到 C++》这一课的内容来看，C++ 的引用的使用场景确实都可以用指针来代替。但是，我们之后会讲到“运算符重载”，为了实现必要的运算符重载操作，引用是不可或缺的。

### 函数返回引用是什么意思？为什么这样就能 `cin >>` 一个函数调用的结果？

一言以蔽之：函数返回引用是将**函数调用表达式**作为某个变量的别名。比如，如果函数 `f`返回 `int&`，那么 `cin >> f();` 就是输入到某个 `int` 类型变量，而 `f() = 42;` 就是对这个变量赋值。

具体是哪个变量的别名呢？也很显然，就是你在函数定义的 `return` 语句中给出的变量名。如果你在 `f` 的定义中 `return a;`，那么 `f()` 就是 `a` 的别名。这个逻辑没有那么困难，只是需要转变一下思维。

### `const T&` 作为函数返回值类型时，能否用来返回局部变量？

不可以。任何情况下返回绑定到局部变量的引用，都是**悬垂引用**。

意思就是 `T&`、`const T&`、`T&&` 等等类型都是引用类型，它们一旦出现在返回值类型的位置，就意味着悬垂引用的可能性。

当引用绑定到局部变量时，函数返回后这个局部变量已经消亡，从而函数调用表达式的结果是一个不存在的变量的别名，从而导致未定义行为。

或许你的编译器和运行环境比较“巧”，没有出现意外的错误；但这仍然是很危险的。

### Lambda 表达式的捕获语法 `[]` 是什么？

当 Lambda 表达式没有捕获时，它的表现和普通函数一样：只能访问函数体内的局部变量、形参，以及全局变量；不能访问其它函数的局部变量。比如，尽管某个 Lambda 表达式定义在 `main` 函数体内，但它仍然不能访问 `main` 当中的局部变量——因为对于 Lambda 表达式而言，`main` 是一个不同的函数，不能访问别人的局部变量。

然而在使用 Lambda 时，访问其它函数的局部变量又是非常常见的需求，所以才有了“捕获列表”。所有在捕获列表中出现的名字，都会复制一份到 Lambda 表达式内部，如同 Lambda 表达式函数体本身的局部变量。如果以“引用捕获”形式写出的名字（即 `&foo` 这种），则会如同 Lambda 表达式内部声明了一个绑定到外界函数局部变量的引用（如果在调用 Lambda 表达式前，外界函数已经返回了，那么这就是悬垂引用）。

`[=]` 用于将所有的外部变量以值复制的形式捕获，`[&]` 用于将所有的外部变量以引用形式捕获。

### 为什么 `C a = C(...)` 没有调用复制构造函数？

关于复制构造函数的调用时机，上课时提到“用一个对象去初始化同类的另一个对象时”会调用复制构造函数，但在ppt的28页里，`Test array2[3] = {Test(2, 3), Test(1, 2), 1};` 这一句实际上不会调用复制构造函数，而会调用普通的构造函数 `Test(int, int)`。这是否是一个特例？

非常好的问题。你的观察是正确的，这个例子**理论上**应当先调用一次 `Test(int, int)`，随后调用复制构造函数将这个临时值复制到 `array2`的元素中。但是编译器在这里做了优化，将第二步给去掉——即直接从两个 `int`构造 `array2[_]`。

另外，C++17 通过对“纯右值”这一术语的修正，强制性要求编译器实现这一优化。所以你此时不可能看到复制构造函数被调用。不过，如果你将标准降到 C++14，并**同时**关闭编译器优化，就可以观察到复制构造函数被调用了。[演示代码](https://godbolt.org/z/aKhf5dK5d)，尝试修改编译器参数以观察结果的不同。

### 函数析构的时候到底发生了什么？析构顺序是？

一个不够精确的结论：调用析构函数、释放所有“基本类型”的变量、按构造顺序的逆序调用所有成员类的析构函数

（对于继承类和父类相关，等学习完相关内容后再补充）

来源：https://en.cppreference.com/w/cpp/language/destructor

对于如何自己寻找此类问题的答案，见[如何找到问题的答案](/24spring/before_ask/how_to_find_answers)。